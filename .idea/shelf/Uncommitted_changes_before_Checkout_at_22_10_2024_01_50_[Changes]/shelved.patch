Index: environment/FarkelEnv.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import numpy as np\r\nimport random\r\nfrom gymnasium import spaces\r\n\r\nclass FarkleEnv:\r\n    def __init__(self, num_players=2, target_score=1000):\r\n        self.num_players = int(num_players)\r\n        self.target_score = target_score\r\n        self.observation_space = spaces.Box(\r\n            low=np.array([0, 0, 0] + [0] * self.num_players + [0] * 6 + [0]),\r\n            high=np.array([self.num_players - 1, target_score, 6] + [target_score] * self.num_players + [6] * 6 + [1]),\r\n            dtype=np.int32\r\n        )\r\n        self.action_space = spaces.Discrete(128)\r\n        self.reset()\r\n        self.stop = False\r\n\r\n    def reset(self, seed=None):\r\n        if seed is not None:\r\n            random.seed(seed)\r\n            np.random.seed(seed)\r\n        self.scores = [0] * self.num_players\r\n        self.current_player = 0\r\n        self.round_score = 0\r\n        self.remaining_dice = 6\r\n        self.dice_roll = self.roll_dice(self.remaining_dice)\r\n        self.game_over = False\r\n        self.last_action_stop = False\r\n        return self.get_observation(), {}\r\n\r\n    def get_observation(self):\r\n        padded_dice = self.dice_roll + [0] * (6 - len(self.dice_roll))\r\n        return np.array([self.current_player, self.round_score, self.remaining_dice] +\r\n                        self.scores + padded_dice + [int(self.last_action_stop)])\r\n\r\n    def roll_dice(self, num_dice):\r\n        return [random.randint(1, 6) for _ in range(num_dice)]\r\n\r\n    def get_valid_actions(self):\r\n        valid_mask = np.zeros(128, dtype=np.int8)\r\n        for action in range(128):\r\n            binary = format(action, '07b')\r\n            action_list = [int(b) for b in binary]\r\n            if self._validate_dice_selection(self.dice_roll, action_list[:len(self.dice_roll)] + [0] * (6 - len(self.dice_roll)) + [action_list[-1]]):\r\n                valid_mask[action] = 1\r\n                print(action, action_list)\r\n\r\n        return valid_mask\r\n\r\n    def _validate_dice_selection(self, dice_roll, action):\r\n\r\n        if len(action) < len(dice_roll):\r\n            return False\r\n\r\n        if action == [1] * 7:\r\n            return False\r\n        \r\n        for d, a in zip(dice_roll, action[:6]):\r\n            if d == 0 and a == 1:\r\n                return False\r\n        \r\n        selected_dice = [d for i, d in enumerate(dice_roll) if action[i] == 1]\r\n        if not selected_dice:\r\n            return False\r\n\r\n        if sorted(selected_dice) == [1, 2, 3, 4, 5, 6]:\r\n            return True\r\n\r\n        selected_counts = [selected_dice.count(i) for i in range(1, 7)]\r\n\r\n        if len(selected_dice) == 6 and selected_counts.count(2) == 3:\r\n            return True\r\n\r\n        valid_singles = {1, 5}\r\n\r\n        f_counts = 0\r\n        for value, count in enumerate(selected_counts, start=1):\r\n            if count > 0:\r\n                # original_count = dice_roll.count(value)\r\n                if value not in valid_singles and count < 3: # and original_count < 3:\r\n                    f_counts += 1\r\n\r\n        if f_counts > 0:\r\n            if f_counts == (6 - selected_counts.count(0)) and (action[:6] == [1] * 6 or action[:6] == [0] * 6):\r\n                return True\r\n            else:\r\n                return False\r\n        else:\r\n            return True\r\n\r\n    def _calculate_score(self, dice_roll, use_restriction = True):\r\n\r\n        if not dice_roll:\r\n            return 0\r\n\r\n        counts = [dice_roll.count(i) for i in range(1, 7)]\r\n        score = 0\r\n        if sorted(dice_roll) == [1, 2, 3, 4, 5, 6]:\r\n            return 1500\r\n\r\n        if counts.count(2) == 3:\r\n            return 1000\r\n\r\n        for die in range(3, 7):\r\n            if die in counts:\r\n                for i, num in enumerate(counts):\r\n                    if counts[i] == die:\r\n                        coef = 1000 if (i + 1) == 1 else 100\r\n                        score += (i + 1) * coef * 2 ** (die - 3)\r\n\r\n        score += counts[0] * 100 if counts[0] < 3 else 0\r\n        score += counts[4] * 50 if counts[4] < 3 else 0\r\n\r\n        if use_restriction:\r\n            score = 0 if counts[1] < 3 and counts[1] != 0 else score\r\n            score = 0 if counts[2] < 3 and counts[2] != 0 else score\r\n            score = 0 if counts[3] < 3 and counts[3] != 0 else score\r\n            score = 0 if counts[5] < 3 and counts[5] != 0 else score\r\n\r\n        return score\r\n\r\n    def step(self, action):\r\n        if self.current_player == 1:\r\n            action = self.get_random_action()\r\n\r\n        print(self.get_valid_actions())\r\n        action_list = action\r\n        print(self.dice_roll)\r\n        print(action)\r\n        if not self._validate_dice_selection(self.dice_roll, action_list[:len(self.dice_roll)]):\r\n            return self.get_observation(), -100, True, False, {\"invalid_action\": True}\r\n\r\n        kept_dice = [self.dice_roll[i] for i in range(len(self.dice_roll)) if action_list[i] == 1]\r\n        print(kept_dice)\r\n\r\n        new_score = self._calculate_score(self.dice_roll, False)\r\n\r\n        if new_score == 0 and self.remaining_dice == 6:\r\n            self.round_score = self.round_score + 500\r\n            self.next_player()\r\n            return self.get_observation(), 500, False, False, {\"stopped\": True}\r\n\r\n        new_score = self._calculate_score(kept_dice, not (self.stop))\r\n        if new_score == 0:\r\n            lost_points = self.round_score\r\n            self.round_score = 0\r\n            self.next_player()\r\n            return self.get_observation(), -lost_points, False, False, {\"farkle\": True, \"lost_points\": lost_points}\r\n\r\n        self.round_score += new_score\r\n        self.remaining_dice -= sum(action_list[:len(self.dice_roll)])\r\n\r\n        if self.remaining_dice == 0:\r\n            self.remaining_dice = 6\r\n\r\n        self.last_action_stop = bool(action_list[-1])\r\n        if self.last_action_stop:\r\n            self.scores[self.current_player] += self.round_score\r\n            reward = self.round_score\r\n            if self.scores[self.current_player] >= self.target_score:\r\n                self.game_over = True\r\n                return self.get_observation(), reward, True, False, {\"win\": True}\r\n            self.next_player()\r\n            return self.get_observation(), reward, False, False, {\"stopped\": True}\r\n\r\n        self.dice_roll = self.roll_dice(self.remaining_dice)\r\n        return self.get_observation(), new_score, False, False, {}\r\n\r\n    def next_player(self):\r\n        self.current_player = (self.current_player + 1) % self.num_players\r\n        self.round_score = 0\r\n        self.remaining_dice = 6\r\n        self.dice_roll = self.roll_dice(self.remaining_dice)\r\n        self.last_action_stop = False\r\n\r\n    def get_random_action(self):\r\n        valid_actions = self.get_valid_actions()\r\n        valid_indices = np.where(valid_actions == 1)[0]\r\n        if len(valid_indices) > 0:\r\n            random_action = random.choice(valid_indices)\r\n            return [int(b) for b in format(random_action, '07b')]\r\n        else:\r\n            return [0] * 6 + [1]\r\n        \r\nfrkl = FarkleEnv()\r\n# print(frkl.get_observation())\r\nfrkl.dice_roll = [2, 3, 4, 3, 0, 0]\r\nfrkl.dice_roll = [3, 3, 5, 5, 1, 3]\r\nfrkl.dice_roll = [2, 3, 4, 6, 0, 0]\r\n# frkl.dice_roll = frkl.roll_dice(frkl.remaining_dice)\r\n# print(frkl.get_observation())\r\n# print(frkl.get_valid_actions())\r\nprint(frkl.get_random_action())
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/environment/FarkelEnv.py b/environment/FarkelEnv.py
--- a/environment/FarkelEnv.py	(revision 8643ddb816560ceac2a568b6a0b8699a79b96146)
+++ b/environment/FarkelEnv.py	(date 1729554558948)
@@ -119,7 +119,7 @@
 
         return score
 
-    def step(self, action):
+    def step(self, action ):
         if self.current_player == 1:
             action = self.get_random_action()
 
@@ -184,10 +184,10 @@
         
 frkl = FarkleEnv()
 # print(frkl.get_observation())
-frkl.dice_roll = [2, 3, 4, 3, 0, 0]
+#frkl.dice_roll = [1, 3, 4, 3, 0, 0]
 frkl.dice_roll = [3, 3, 5, 5, 1, 3]
-frkl.dice_roll = [2, 3, 4, 6, 0, 0]
-# frkl.dice_roll = frkl.roll_dice(frkl.remaining_dice)
-# print(frkl.get_observation())
-# print(frkl.get_valid_actions())
+#frkl.dice_roll = [2, 3, 4, 6, 0, 0]
+#frkl.dice_roll = frkl.roll_dice(frkl.remaining_dice)
+print(frkl.get_observation())
+print(frkl.get_valid_actions())
 print(frkl.get_random_action())
\ No newline at end of file
Index: environment/tictactoe_new.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import random\r\nimport numpy as np\r\nfrom typing import List, Tuple\r\n\r\nNUM_ACTIONS = 9\r\nNUM_STATE_FEATURES = 27\r\n\r\n\r\nclass TicTacToe_new:\r\n    def __init__(self):\r\n        self._board = np.zeros((NUM_ACTIONS,))\r\n        self._player = 0\r\n        self._is_game_over = False\r\n        self._score = 0.0\r\n\r\n    def reset(self):\r\n        self._board = np.zeros((NUM_ACTIONS,))\r\n        self._player = 0\r\n        self._is_game_over = False\r\n        self._score = 0.0\r\n\r\n    def state_description(self) -> np.ndarray:\r\n        \"\"\"\r\n        Encode l'état du plateau de TicTacToe dans un vecteur de 27 éléments (3 valeurs par case).\r\n        - [1, 0, 0] pour \"X\" (Joueur 1).\r\n        - [0, 1, 0] pour \"O\" (Joueur 2).\r\n        - [0, 0, 1] pour une case vide.\r\n        \"\"\"\r\n        state_description = np.zeros((NUM_STATE_FEATURES,))\r\n\r\n        for i in range(NUM_ACTIONS):\r\n            if self._board[i] == 1.0:  # Case occupée par \"X\" (Joueur 1)\r\n                state_description[i * 3] = 1.0  # Première des trois valeurs pour \"X\"\r\n            elif self._board[i] == 2.0:  # Case occupée par \"O\" (Joueur 2)\r\n                state_description[i * 3 + 1] = 1.0  # Deuxième des trois valeurs pour \"O\"\r\n            else:\r\n                state_description[i * 3 + 2] = 1.0  # Troisième des trois valeurs pour une case vide\r\n        return state_description\r\n\r\n    def available_actions_ids(self) -> np.ndarray:\r\n        return np.where(self._board == 0)[0]\r\n\r\n    def action_mask(self) -> np.ndarray:\r\n        return np.where(self._board == 0, 1, 0).astype(np.float32)\r\n\r\n    def step(self, action: int):\r\n        if self._is_game_over:\r\n            raise ValueError(\"Game is over, please reset the environment.\")\r\n\r\n        if action < 0 or action >= NUM_ACTIONS:\r\n            raise ValueError(\"Invalid move, action must be in [0, 8].\")\r\n\r\n        if self._board[action] != 0:\r\n            raise ValueError(\"Invalid move, cell is already occupied.\")\r\n\r\n        # Mise à jour du plateau\r\n        self._board[action] = self._player + 1\r\n\r\n        row = action // 3\r\n        col = action % 3\r\n\r\n        # Vérification des lignes\r\n        if self._board[row * 3] == self._board[row * 3 + 1] == self._board[row * 3 + 2]:\r\n            self._is_game_over = True\r\n            self._score = 1.0 if self._player == 0 else -1.0\r\n            return\r\n\r\n        # Vérification des colonnes\r\n        if self._board[col] == self._board[col + 3] == self._board[col + 6]:\r\n            self._is_game_over = True\r\n            self._score = 1.0 if self._player == 0 else -1.0\r\n            return\r\n\r\n        # Vérification des diagonales si l'action est dans une case de diagonale\r\n        if action in [0, 4, 8]:  # Diagonale principale\r\n            if self._board[0] == self._board[4] == self._board[8]:\r\n                self._is_game_over = True\r\n                self._score = 1.0 if self._player == 0 else -1.0\r\n                return\r\n\r\n        if action in [2, 4, 6]:  # Diagonale secondaire\r\n            if self._board[2] == self._board[4] == self._board[6]:\r\n                self._is_game_over = True\r\n                self._score = 1.0 if self._player == 0 else -1.0\r\n                return\r\n\r\n        # Vérification du match nul\r\n        if np.all(self._board != 0):\r\n            self._is_game_over = True\r\n            self._score = 0.0\r\n            return\r\n\r\n        # Changement de joueur\r\n        self._player = 1 if self._player == 0 else 0\r\n\r\n        # Si c'est au tour de l'adversaire aléatoire, il joue automatiquement\r\n        if self._player == 1:\r\n            random_action = np.random.choice(self.available_actions_ids())\r\n            self.step(random_action)\r\n\r\n    def is_game_over(self) -> bool:\r\n        return self._is_game_over\r\n\r\n    def score(self) -> float:\r\n        return self._score\r\n\r\n\r\n    def display(self):\r\n        \"\"\"Affiche le plateau de jeu.\"\"\"\r\n        for i in range(3):\r\n            print(\"|\".join([\"_\" if self._board[i * 3 + j] == 0.0 else \"X\" if self._board[i * 3 + j] == 1.0 else \"O\" for j in range(3)]))\r\n        print(f\"Score : {self._score}\")\r\n        print(f\"Joueur {'X' if self._player == 0 else 'O'} à jouer\")\r\n        print(f\"Jeu terminé : {self._is_game_over}\")\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/environment/tictactoe_new.py b/environment/tictactoe_new.py
--- a/environment/tictactoe_new.py	(revision 8643ddb816560ceac2a568b6a0b8699a79b96146)
+++ b/environment/tictactoe_new.py	(date 1729554558963)
@@ -89,7 +89,8 @@
             self._is_game_over = True
             self._score = 0.0
             return
-
+        print(self.available_actions_ids())
+        print
         # Changement de joueur
         self._player = 1 if self._player == 0 else 0
 
