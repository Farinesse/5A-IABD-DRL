Index: environment/FarkelEnv.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import numpy as np\r\nimport random\r\nfrom gymnasium import spaces\r\n\r\nclass FarkleEnv:\r\n    def __init__(self, num_players=2, target_score=1000):\r\n        self.num_players = int(num_players)\r\n        self.target_score = target_score\r\n        self.observation_space = spaces.Box(\r\n            low=np.array([0, 0, 0] + [0] * self.num_players + [0] * 6 + [0]),\r\n            high=np.array([self.num_players - 1, target_score, 6] + [target_score] * self.num_players + [6] * 6 + [1]),\r\n            dtype=np.int32\r\n        )\r\n        self.action_space = spaces.Discrete(128)\r\n        self.reset()\r\n        self.stop = False\r\n\r\n    def reset(self, seed=None):\r\n        if seed is not None:\r\n            random.seed(seed)\r\n            np.random.seed(seed)\r\n        self.scores = [0] * self.num_players\r\n        self.current_player = 0\r\n        self.round_score = 0\r\n        self.remaining_dice = 6\r\n        self.dice_roll = self.roll_dice(self.remaining_dice)\r\n        self.game_over = False\r\n        self.last_action_stop = False\r\n        return self.get_observation(), {}\r\n\r\n    def get_observation(self):\r\n        padded_dice = self.dice_roll + [0] * (6 - len(self.dice_roll))\r\n        return np.array([self.current_player, self.round_score, self.remaining_dice] +\r\n                        self.scores + padded_dice + [int(self.last_action_stop)])\r\n\r\n    def roll_dice(self, num_dice):\r\n        return [random.randint(1, 6) for _ in range(num_dice)]\r\n\r\n    def get_valid_actions(self):\r\n        valid_mask = np.zeros(128, dtype=np.int8)\r\n        for action in range(128):\r\n            binary = format(action, '07b')\r\n            action_list = [int(b) for b in binary]\r\n            if self._validate_dice_selection(self.dice_roll, action_list[:len(self.dice_roll)] + [0] * (6 - len(self.dice_roll)) + [action_list[-1]]):\r\n                valid_mask[action] = 1\r\n                print(action, action_list)\r\n\r\n        return valid_mask\r\n\r\n    def _validate_dice_selection(self, dice_roll, action):\r\n\r\n        if len(action) < len(dice_roll):\r\n            return False\r\n\r\n        if action == [1] * 7:\r\n            return False\r\n        \r\n        selected_dice = [d for i, d in enumerate(dice_roll) if action[i] == 1]\r\n        if not selected_dice:\r\n            return False\r\n\r\n        if sorted(selected_dice) == [1, 2, 3, 4, 5, 6]:\r\n            return True\r\n\r\n        selected_counts = [selected_dice.count(i) for i in range(1, 7)]\r\n\r\n        if len(selected_dice) == 6 and selected_counts.count(2) == 3:\r\n            return True\r\n\r\n        valid_singles = {1, 5}\r\n\r\n        f_counts = 0\r\n        for value, count in enumerate(selected_counts, start=1):\r\n            if count > 0:\r\n                # original_count = dice_roll.count(value)\r\n                if value not in valid_singles and count < 3: # and original_count < 3:\r\n                    f_counts += 1\r\n\r\n        if f_counts > 0:\r\n            if f_counts == (6 - selected_counts.count(0)) and (action[:6] == [1] * 6 or action[:6] == [0] * 6):\r\n                return True\r\n            else:\r\n                return False\r\n        else:\r\n            return True\r\n\r\n    def _calculate_score(self, dice_roll, use_restriction = True):\r\n\r\n\r\n        if not dice_roll:\r\n            return 0\r\n\r\n        counts = [dice_roll.count(i) for i in range(1, 7)]\r\n        score = 0\r\n        if sorted(dice_roll) == [1, 2, 3, 4, 5, 6]:\r\n            return 1500\r\n\r\n        if counts.count(2) == 3:\r\n            return 1000\r\n\r\n        for die in range(3, 7):\r\n            if die in counts:\r\n                for i, num in enumerate(counts):\r\n                    if counts[i] == die:\r\n                        coef = 1000 if (i + 1) == 1 else 100\r\n                        score += (i + 1) * coef * 2 ** (die - 3)\r\n\r\n        score += counts[0] * 100 if counts[0] < 3 else 0\r\n        score += counts[4] * 50 if counts[4] < 3 else 0\r\n\r\n        if use_restriction:\r\n            score = 0 if counts[1] < 3 and counts[1] != 0 else score\r\n            score = 0 if counts[2] < 3 and counts[2] != 0 else score\r\n            score = 0 if counts[3] < 3 and counts[3] != 0 else score\r\n            score = 0 if counts[5] < 3 and counts[5] != 0 else score\r\n\r\n\r\n\r\n        return score\r\n\r\n    def step(self, action):\r\n        if self.current_player == 1:\r\n            action = self.get_random_action()\r\n\r\n        print(self.get_valid_actions())\r\n        action_list = action\r\n        print(self.dice_roll)\r\n        print(action)\r\n        if not self._validate_dice_selection(self.dice_roll, action_list[:len(self.dice_roll)]):\r\n            return self.get_observation(), -100, True, False, {\"invalid_action\": True}\r\n\r\n        kept_dice = [self.dice_roll[i] for i in range(len(self.dice_roll)) if action_list[i] == 1]\r\n        print(kept_dice)\r\n\r\n        new_score = self._calculate_score(self.dice_roll, False)\r\n\r\n        if new_score == 0 and self.remaining_dice == 6:\r\n            self.round_score = self.round_score + 500\r\n            self.next_player()\r\n            return self.get_observation(), 500, False, False, {\"stopped\": True}\r\n\r\n        new_score = self._calculate_score(kept_dice, not (self.stop))\r\n        if new_score == 0:\r\n            lost_points = self.round_score\r\n            self.round_score = 0\r\n            self.next_player()\r\n            return self.get_observation(), -lost_points, False, False, {\"farkle\": True, \"lost_points\": lost_points}\r\n\r\n        self.round_score += new_score\r\n        self.remaining_dice -= sum(action_list[:len(self.dice_roll)])\r\n\r\n        if self.remaining_dice == 0:\r\n            self.remaining_dice = 6\r\n\r\n        self.last_action_stop = bool(action_list[-1])\r\n        if self.last_action_stop:\r\n            self.scores[self.current_player] += self.round_score\r\n            reward = self.round_score\r\n            if self.scores[self.current_player] >= self.target_score:\r\n                self.game_over = True\r\n                return self.get_observation(), reward, True, False, {\"win\": True}\r\n            self.next_player()\r\n            return self.get_observation(), reward, False, False, {\"stopped\": True}\r\n\r\n        self.dice_roll = self.roll_dice(self.remaining_dice)\r\n        return self.get_observation(), new_score, False, False, {}\r\n\r\n    def next_player(self):\r\n        self.current_player = (self.current_player + 1) % self.num_players\r\n        self.round_score = 0\r\n        self.remaining_dice = 6\r\n        self.dice_roll = self.roll_dice(self.remaining_dice)\r\n        self.last_action_stop = False\r\n\r\n    def get_random_action(self):\r\n        valid_actions = self.get_valid_actions()\r\n        valid_indices = np.where(valid_actions == 1)[0]\r\n        if len(valid_indices) > 0:\r\n            random_action = random.choice(valid_indices)\r\n            return [int(b) for b in format(random_action, '07b')]\r\n        else:\r\n            return [0] * 6 + [1]\r\n        \r\nfrkl = FarkleEnv()\r\nprint(frkl.get_observation())\r\nfrkl.dice_roll = [2, 3, 4, 3, 6, 2]\r\n# frkl.dice_roll = [3, 3, 5, 5, 1, 3]\r\n# frkl.dice_roll = frkl.roll_dice(frkl.remaining_dice)\r\nprint(frkl.get_observation())\r\nprint(frkl.get_valid_actions())
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/environment/FarkelEnv.py b/environment/FarkelEnv.py
--- a/environment/FarkelEnv.py	
+++ b/environment/FarkelEnv.py	
@@ -183,7 +183,7 @@
         
 frkl = FarkleEnv()
 print(frkl.get_observation())
-frkl.dice_roll = [2, 3, 4, 3, 6, 2]
+frkl.dice_roll = [5, 3, 1, 3, 5, 2]
 # frkl.dice_roll = [3, 3, 5, 5, 1, 3]
 # frkl.dice_roll = frkl.roll_dice(frkl.remaining_dice)
 print(frkl.get_observation())
